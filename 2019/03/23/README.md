## 通俗易懂的讲解字符串匹配的**KMP**算法

前言：其实关于这篇文章早就应该写完的，但是由于自己的拖延症，一直迟迟没有没有下笔；由于工作上一直也挺忙的，博客也好久没有更新了。最近刚好有时间就赶紧把
这篇文章完成了，不然估计又要拖好久。

关于**KMP**算法的讲解，网上其实已经有很多资料了；但是我觉得很多讲的都不是那么通俗易懂，让大家看起来很费劲；我试图用最方便大家理解的方式，来给大家讲解一下
这个算法的原理。

让我们直接进入主题，字符串的检索匹配应该是我们开发的过程中经常遇到的问题了。假如现在有这么一个需求：
```
有两个字符串T和P；需要我们从T中找出与P字符串匹配的下标的位置
```

当然，如果不考虑效率的话，我们会很快的写出下面的代码：
```javascript
// JavaScript 版本代码
function searchPatternIndex(T, P) {
  // 计算T和P的长度
  const tLen = T.length;
  const pLen = P.length;

  // 要查找的位置，默认是0
  let i0 = 0;

  // T和P字符串查找比对的位置
  let i = 0;
  let j = 0;

  while (i < tLen) {
    // T和P当前位置的字符相等
    if (T[i] === P[j]) {
      i++;
      j++;
      // 找到P的位置
      if (j === pLen) {
        return i0;
      }
    } else {
      // 如果不相等的话，i0的位置向后移动一位
      i0++;
      // 从新的位置开始对比
      i = i0;
      // 再次从P字符串的开始进行比对
      j = 0;
    }
  }
  // 没有找到的话返回-1
  return -1;
}

// 测试代码
console.log(searchPatternIndex("jkajsdiuuqiwenasdjhababanbajhsdyqbhjabduagd", "ababa")); // 19
```

上面的代码虽然能够达到我们的目的，但是在字符串T和P的长度比较大的情况下，上面的代码的效率就很低。那么我们应该如何改进上面的算法呢？

我们不妨这样想一下，假设在我们发现`T[i]`和`P[j]`不相同的时候，我们已经有`m`个相同的字符了；就如下图这样：

![图1](images/kmp-1.png)

我们知道`T[i]`和`P[j]`不相同也就是上图中的`x`和`y`不相同，但是我们还不知道`x`和`y`表示的具体的值；这个时候我们可不可以将
字符串`P`向后移动多个位置，但是还是可以确保我们没有漏掉相应的匹配呢？我们可以尝试将`P`向后一位一位的移动，然后在分析比较；我把这个过程
用下图表示：

![图2](images/kmp-2.png)

由上图我们可知，当将`P`向后移动3位的时候，T和P才有可能



























